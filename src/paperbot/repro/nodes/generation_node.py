# repro/nodes/generation_node.py
"""
Generation Node for Paper2Code pipeline.
Phase 3: Generate code files based on plan and spec.
"""

import logging
from typing import Dict, Any, Optional, List
from .base_node import BaseNode, NodeResult
from ..models import PaperContext, ReproductionPlan, ImplementationSpec

logger = logging.getLogger(__name__)

try:
    from claude_agent_sdk import query, ClaudeAgentOptions
except Exception:
    query = None
    ClaudeAgentOptions = None


class GenerationNode(BaseNode[Dict[str, str]]):
    """
    Generate code files based on plan and spec.
    
    Input: (PaperContext, ReproductionPlan, ImplementationSpec)
    Output: Dict[str, str] mapping filename to content
    """
    
    CODE_GEN_PROMPT = """Generate Python code for this file.

Paper: {title}
File: {filepath}
Purpose: {purpose}
Components: {components}
Specs: {specs}

Generate clean, well-documented Python code. Include:
- Docstrings
- Type hints
- Basic error handling

Output ONLY the Python code, no markdown.
"""

    def __init__(self, llm_client=None, **kwargs):
        super().__init__(node_name="GenerationNode", **kwargs)
        self.llm_client = llm_client
    
    def _validate_input(self, input_data: Any, **kwargs) -> Optional[str]:
        """Validate input tuple."""
        if not isinstance(input_data, tuple) or len(input_data) != 3:
            return "Input must be (PaperContext, ReproductionPlan, ImplementationSpec)"
        return None
    
    async def _execute(self, input_data: tuple, **kwargs) -> Dict[str, str]:
        """Generate all code files."""
        paper_context, plan, spec = input_data
        
        files = {}
        for filepath, purpose in plan.files:
            code = await self._generate_file(filepath, purpose, paper_context, plan, spec)
            files[filepath] = code
        
        # Add requirements.txt
        files["requirements.txt"] = self._generate_requirements(plan)
        
        return files
    
    async def _generate_file(
        self,
        filepath: str,
        purpose: str,
        paper_context: PaperContext,
        plan: ReproductionPlan,
        spec: ImplementationSpec
    ) -> str:
        """Generate a single code file."""
        # Try LLM generation
        if query and ClaudeAgentOptions:
            try:
                prompt = self.CODE_GEN_PROMPT.format(
                    title=paper_context.title,
                    filepath=filepath,
                    purpose=purpose,
                    components=", ".join(plan.components),
                    specs=str(spec.component_specs)[:500]
                )
                
                result = query(
                    prompt=prompt,
                    options=ClaudeAgentOptions(max_tokens=2000)
                )
                
                return self._clean_code(result.response)
            except Exception as e:
                logger.warning(f"LLM generation failed for {filepath}: {e}")
        
        # Fallback template
        return self._fallback_template(filepath, purpose, plan, spec)
    
    def _clean_code(self, response: str) -> str:
        """Remove markdown code blocks if present."""
        if response.startswith("```"):
            lines = response.split("\n")
            # Remove first and last line (```python and ```)
            lines = [l for l in lines if not l.startswith("```")]
            return "\n".join(lines)
        return response
    
    def _generate_requirements(self, plan: ReproductionPlan) -> str:
        """Generate requirements.txt."""
        return "\n".join(plan.dependencies)
    
    def _fallback_template(
        self,
        filepath: str,
        purpose: str,
        plan: ReproductionPlan,
        spec: ImplementationSpec
    ) -> str:
        """Generate fallback template code."""
        basename = filepath.replace(".py", "").replace("/", "_")
        
        if "main" in filepath.lower():
            return self._template_main(plan, spec)
        elif "model" in filepath.lower():
            return self._template_model(spec)
        elif "data" in filepath.lower():
            return self._template_data(spec)
        elif "config" in filepath.lower():
            return self._template_config(spec)
        else:
            return self._template_generic(basename, purpose)
    
    def _template_main(self, plan: ReproductionPlan, spec: ImplementationSpec) -> str:
        return f'''"""
{plan.title} - Main Entry Point
Auto-generated by PaperBot ReproAgent
"""

import argparse
from config import Config
from model import Model
from data import DataLoader


def main():
    parser = argparse.ArgumentParser(description="{plan.title}")
    parser.add_argument("--config", default="config.yaml")
    args = parser.parse_args()
    
    config = Config()
    model = Model(config)
    data = DataLoader(config)
    
    print(f"Running: {plan.title}")
    # TODO: Implement training/inference loop


if __name__ == "__main__":
    main()
'''
    
    def _template_model(self, spec: ImplementationSpec) -> str:
        return '''"""Model implementation."""

class Model:
    """Main model class."""
    
    def __init__(self, config):
        self.config = config
    
    def forward(self, x):
        """Forward pass."""
        raise NotImplementedError
    
    def train(self, data):
        """Training loop."""
        raise NotImplementedError
'''
    
    def _template_data(self, spec: ImplementationSpec) -> str:
        return f'''"""Data loading utilities."""

class DataLoader:
    """Data loader class."""
    
    def __init__(self, config):
        self.config = config
        self.data_format = "{spec.data_format}"
    
    def load(self, path: str):
        """Load data from file."""
        raise NotImplementedError
    
    def preprocess(self, data):
        """Preprocess data."""
        raise NotImplementedError
'''
    
    def _template_config(self, spec: ImplementationSpec) -> str:
        hp = spec.hyperparameters
        return f'''"""Configuration."""

class Config:
    """Configuration class."""
    
    learning_rate = {hp.get("learning_rate", 0.001)}
    batch_size = {hp.get("batch_size", 32)}
    epochs = {hp.get("epochs", 10)}
'''
    
    def _template_generic(self, name: str, purpose: str) -> str:
        return f'''"""
{purpose}
Auto-generated by PaperBot ReproAgent
"""

# TODO: Implement {name}
'''

